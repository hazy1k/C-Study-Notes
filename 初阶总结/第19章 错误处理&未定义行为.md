# 第十九章 错误处理&未定义行为

## 19.1 C错误处理

C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 **errno**，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。

### 19.1.1 errno、perror()和strerror()

C 语言提供了 **perror()** 和 **strerror()** 函数来显示与 **errno** 相关的文本消息。

- **perror()** 函数显示我们传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
- **strerror()** 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。

让我们来模拟一种错误情况，尝试打开一个不存在的文件。当然可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，应该使用 **stderr** 文件流来输出所有的错误。

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno ;

int main ()
{
   FILE * pf; // 文件指针
   int errnum;

   // 打开一个不存在的文件-模拟错误
   pf = fopen ("unexist.txt", "rb"); // 打开文件失败，返回 NULL
   if (pf == NULL)
   {
      errnum = errno; // 获取错误号
      fprintf(stderr, "错误号: %d\n", errno);
      
      perror("通过 perror 输出错误");
      fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
   }
   else
   {
      fclose (pf);
   }
   return 0;
}
```

### 19.1.2 被零除的错误

在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。

为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int dividend = 20; // 除数
    int divisor = 0; // 被除数为 0
    int quotient; // 商

    // 除数为 0 退出运行
    if( divisor == 0){
        fprintf(stderr, "除数为 0 退出运行...\n");
        exit(-1);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "quotient 变量的值为 : %d\n", quotient );

    exit(0);
}
```

### 19.1.3 程序退出状态

通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。

如果程序中存在一种错误情况，当我们退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int dividend = 20;
    int divisor = 5;
    int quotient;

    if( divisor == 0){
        fprintf(stderr, "除数为 0 退出运行...\n");
        exit(EXIT_FAILURE);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "quotient 变量的值为: %d\n", quotient );

    exit(EXIT_SUCCESS);
}
```

## 19.2 C未定义行为

在 C 语言中，**"undefined behavior"（未定义行为）**是指程序的行为在 C 语言标准中没有明确定义，因此可以表现为任何结果。

这意味着当程序出现未定义行为时，它可能会产生不可预测的结果，包括程序崩溃、数据损坏、安全漏洞，甚至可能看起来正常运行。

未定义行为是C语言中一个重要的概念，因为它涉及到程序的正确性和安全性。

以下是一些常见的可能导致未定义行为的情况：

### 19.2.1 数组越界

当我们尝试访问数组的越界元素时，即访问数组的第0个元素之前或数组长度之后的元素时，编译器无法确定访问到的内存空间中存储的是什么内容，因此会导致未定义行为。例如：

```c
int arr[3] = {1, 2, 3};
printf("%d\n", arr[5]); // 越界访问，结果未定义
```

### 19.2.2 解引用空指针

当我们尝试对空指针进行解引用操作时，编译器无法确定要访问的内存空间中存储的内容，因此会导致未定义行为。例如：

```c
int *ptr = NULL;
printf("%d\n", *ptr); // 解引用空指针，结果未定义
```

### 19.2.3 未初始化的局部变量

当我们使用未初始化的局部变量时，其值是未定义的，因此会导致未定义行为。例如：

```c
int x;
printf("%d\n", x); // x 未初始化，结果未定义
```

### 19.2.4 浮点数除以零

当我们尝试对浮点数进行除以零的操作时，结果是未定义的。例如：

```c
float x = 1.0;
float y = x / 0.0; // 浮点数除以零，结果未定义
```

### 19.2.5 整数除以零

当我们尝试对整数进行除以零的操作时，结果是未定义的。例如：

```c
int x = 10;
int y = x / 0; // 整数除以零，结果未定义
```

### 19.2.6 符号溢出

当整数运算导致结果超出了整数类型能表示的范围时，结果是未定义的。例如：

```c
signed char x = 127;
x = x + 1; // signed char 溢出，结果未定义
```

### 19.2.7 位操作数太大

当执行位移操作时，位移的位数大于或等于操作数的位数时，结果是未定义的。例如：

```c
int x = 1;
int y = x << 32; // 位移操作数太大，结果未定义
```

### 19.2.8 错误的类型转换

当我们进行不安全的类型转换时，结果是未定义的。例如：

```c
int *ptr = (int *)malloc(sizeof(int));
float *fptr = (float *)ptr; // 错误的类型转换，结果未定义
```

### 19.2.9 内存越界

当我们向已经释放或未分配的内存写入数据时，结果是未定义的。例如：

```c
int *ptr = (int *)malloc(sizeof(int));
free(ptr);
*ptr = 10; // 内存越界，结果未定义
```

### 19.2.10 未定义的浮点数行为

比如比较两个 NaN（非数字）值是否相等，这是未定义的行为。例如：

```c
float x = sqrt(-1);
float y = sqrt(-1);
if (x == y) {
    printf("NaN values are equal\n");
}
```

### 19.2.11 其他未定义行为

还有一些其他未定义的行为：

- 使用未定义的浮点数特性：依赖于特定硬件或实现的浮点数行为，如浮点数的精度或舍入行为。

- 函数参数数量不匹配：调用函数时提供的参数数量与函数定义不匹配，如 printf("%s %d", "Name")。

- 修改字符串字面量：尝试修改字符串字面量的内容，如 char *str = "Hello"; str[0] = 'h';。

- 使用未定义的程序状态：依赖于未定义的程序状态，如全局变量的初始值。

- 违反严格的语法规则：违反 C 语言的严格语法规则，如使用未声明的标识符。

- 多线程中的竞态条件：在多线程环境中，未同步的共享资源访问可能导致未定义行为。

- 使用未定义的标准库函数行为：某些标准库函数在特定条件下的行为可能是未定义的，如 fscanf() 在未匹配到任何输入时的行为。

这些都是在编程过程中需要避免的情况，因为它们可能导致程序在不同的环境下产生不确定的行为，从而使代码不可移植并可能导致程序出现错误。
